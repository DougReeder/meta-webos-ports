From dc551014e438e9833b4a72d1cff3b395cd719c7f Mon Sep 17 00:00:00 2001
From: Sergiy Kryvonos <sergiy.kryvonos@lge.com>
Date: Thu, 23 Apr 2015 20:04:39 +0300
Subject: [PATCH] Fix build for node v0.12.2

:Release Notes:
Updated module for using with Node.js v0.12.2

:Detailed Notes:
Node.js v0.12.2 uses new V8. In this version V8 was changed some
internal structures and interfaces. To make "buildable" this module,
was made changes which use updated V8 interface.

:Testing Performed:
Manual build package performed.

:QA Notes:

:Issues Addressed:
[DRD-8623] nodejs-module-webos-sysbus adoptation for node v0.12.2
Open-webOS-DCO-1.0-Signed-off-by: Sergiy Kryvonos <sergiy.kryvonos@lge.com>
---
 src/generate_templates.rb               |   53 +-
 src/node_ls2.cpp                        |   11 +-
 src/node_ls2_base.cpp                   |    6 +-
 src/node_ls2_call.cpp                   |   44 +-
 src/node_ls2_call.h                     |    8 +-
 src/node_ls2_handle.cpp                 |   74 +-
 src/node_ls2_handle.h                   |   18 +-
 src/node_ls2_member_function_wrappers.h | 1614 +++++++++++++++++--------------
 src/node_ls2_message.cpp                |   81 +-
 src/node_ls2_message.h                  |   28 +-
 src/node_ls2_utils.cpp                  |    6 +-
 11 files changed, 1073 insertions(+), 870 deletions(-)
 mode change 100644 => 100755 src/generate_templates.rb

diff --git a/src/generate_templates.rb b/src/generate_templates.rb
old mode 100644
new mode 100755
index 93d8d0e..a6a318c
--- a/src/generate_templates.rb
+++ b/src/generate_templates.rb
@@ -1,3 +1,4 @@
+#!/usr/bin/env ruby
 # @@@LICENSE
 #
 #      Copyright (c) 2010-2013 LG Electronics, Inc.
@@ -60,27 +61,33 @@ RV_FUNCTION=<<RV_FUNCTION_TEXT
 
 // arity: <%= arity %>, const:<%= const_funcs %>
 
-template <<%= types_decl_rv(arity)%>> v8::Handle<v8::Value> MemberFunctionWrapper(RV (T::*MemFunc)(<%= params_fp_decl(arity) %>)<%= const_funcs %>, v8::Arguments const & args )
+template <<%= types_decl_rv(arity)%>> void MemberFunctionWrapper(RV (T::*MemFunc)(<%= params_fp_decl(arity) %>)<%= const_funcs %>, const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-  if (args.Length() != <%= arity %>) {
-    return ThrowException(v8::Exception::Error(
-      v8::String::New("Invalid number of parameters, <%= arity %> expected.")));
+  v8::Isolate*  isolate = info.GetIsolate();
+  if (info.Length() != <%= arity %>) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, <%= arity %> expected."))));
+    return;
   }
 
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
   if (!o) {
-    return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
   }
 
   try {
     <% (1..arity).each do |i| %>
-      ConvertFromJS<<%= typename_for_index(i) %>> <%= param_name_for_index(i) %>(args[<%= i-1 %>]);
+      ConvertFromJS<<%= typename_for_index(i) %>> <%= param_name_for_index(i) %>(info[<%= i-1 %>]);
     <% end %>
-    return ConvertToJS<RV>((o->*MemFunc)(<%= params_pass(arity) %>));
+    info.GetReturnValue().Set(ConvertToJS<RV>((o->*MemFunc)(<%= params_pass(arity) %>)));
   } catch( std::exception const & ex ) {
-    return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, ex.what()))));
   } catch( ... ) {
-    return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
   }
 }
 
@@ -91,28 +98,34 @@ VOID_FUNCTION=<<VOID_FUNCTION_TEXT
 
 // arity: <%= arity %>, const: <%= const_funcs %>
 
-<%= types_decl(arity)%> v8::Handle<v8::Value> VoidMemberFunctionWrapper(void (T::*MemFunc)(<%= params_fp_decl(arity) %>)<%= const_funcs %>, v8::Arguments const & args )
+<%= types_decl(arity)%> void VoidMemberFunctionWrapper(void (T::*MemFunc)(<%= params_fp_decl(arity) %>)<%= const_funcs %>, const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-  if (args.Length() != <%= arity %>) {
-    return ThrowException(v8::Exception::Error(
-      v8::String::New("Invalid number of parameters, <%= arity %> expected.")));
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != <%= arity %>) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, <%= arity %> expected."))));
+    return;
   }
 
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
   if (!o) {
-    return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
   }
 
   try {
     <% (1..arity).each do |i| %>
-      ConvertFromJS<<%= typename_for_index(i) %>> <%= param_name_for_index(i) %>(args[<%= i-1 %>]);
+      ConvertFromJS<<%= typename_for_index(i) %>> <%= param_name_for_index(i) %>(info[<%= i-1 %>]);
     <% end %>
      (o->*MemFunc)(<%= params_pass(arity) %>);
-     return v8::Undefined();
+     info.GetReturnValue().SetUndefined();
   } catch( std::exception const & ex ) {
-    return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, ex.what()))));
   } catch( ... ) {
-    return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
   }
 }
 
diff --git a/src/node_ls2.cpp b/src/node_ls2.cpp
index ac9e9b3..634b946 100644
--- a/src/node_ls2.cpp
+++ b/src/node_ls2.cpp
@@ -21,6 +21,7 @@
 #include <node.h>
 #include <stdlib.h>
 #include <v8.h>
+#include <uv.h>
 #include <list>
 #include <map>
 #include <algorithm>
@@ -66,12 +67,12 @@ static WatcherMap pollwMap;
 static uv_timer_t timeout_handle;
 static bool query = false;
 
-static void timeout_cb(uv_timer_t* w, int revents)
+static void timeout_cb(uv_timer_t* w)
 {
     /* nop */
 }
 
-static void uv_timeout_cb(uv_timer_t *handle, int status)
+static void uv_timeout_cb(uv_timer_t *handle)
 {
     query = true;
     uv_timer_stop(&timeout_handle);
@@ -110,7 +111,7 @@ static void poll_cb(uv_poll_t* handle, int status, int events)
     uv_poll_stop(handle);
 }
 
-static void prepare_cb(uv_prepare_t* w, int revents)
+static void prepare_cb(uv_prepare_t* w)
 {
     struct econtext* ctx = (struct econtext*)(((char*)w) - offsetof(struct econtext, pw));
     gint timeout;
@@ -221,7 +222,7 @@ static void prepare_cb(uv_prepare_t* w, int revents)
     }
 }
 
-static void check_cb(uv_check_t* w, int revents)
+static void check_cb(uv_check_t* w)
 {
     struct econtext* ctx = (struct econtext*)(((char*)w) - offsetof(struct econtext, cw));
 
@@ -244,7 +245,7 @@ static struct econtext default_context;
 
 void init(Handle<Object> target)
 {
-    HandleScope scope;
+    HandleScope scope(Isolate::GetCurrent());
     gMainLoop = g_main_loop_new(NULL, true);
 
     GMainContext *gc = g_main_context_default();
diff --git a/src/node_ls2_base.cpp b/src/node_ls2_base.cpp
index 6fb05eb..0484649 100644
--- a/src/node_ls2_base.cpp
+++ b/src/node_ls2_base.cpp
@@ -39,7 +39,11 @@ void LS2Base::EmitMessage(const Handle<String>& symbol, LSMessage *message)
         messageObject  // argument
       };
 
-      MakeCallback(this->handle_, "emit", 2, argv);
+      MakeCallback(Isolate::GetCurrent(),
+                   this->handle(),
+                   static_cast<const char*>("emit"),
+                   2,
+                   static_cast<v8::Handle<v8::Value>*>(argv));
     } else {
         // We don't want to silently lose messages
         syslog(LOG_USER | LOG_CRIT, "%s: messageObject is empty", __PRETTY_FUNCTION__);
diff --git a/src/node_ls2_call.cpp b/src/node_ls2_call.cpp
index 3205e38..23b1462 100644
--- a/src/node_ls2_call.cpp
+++ b/src/node_ls2_call.cpp
@@ -39,29 +39,32 @@ static Persistent<String> response_symbol;
 // to the target object.
 void LS2Call::Initialize (Handle<Object> target)
 {
-    HandleScope scope;
+    v8::Isolate* isolate = v8::Isolate::GetCurrent();
+    HandleScope scope(isolate);
 
-    Local<FunctionTemplate> t = FunctionTemplate::New(New);
+    Local<FunctionTemplate> t = FunctionTemplate::New(isolate, New);
 
-    t->SetClassName(String::New("palmbus/Call"));
+    t->SetClassName(v8::String::NewFromUtf8(isolate, "palmbus/Call"));
 
-    gCallTemplate = Persistent<FunctionTemplate>::New(t);
+    gCallTemplate.Reset(isolate, t);
 
     t->InstanceTemplate()->SetInternalFieldCount(1);
 
     NODE_SET_PROTOTYPE_METHOD(t, "cancel", CancelWrapper);
     NODE_SET_PROTOTYPE_METHOD(t, "setResponseTimeout", SetResponseTimeoutWrapper);
 
-    response_symbol = NODE_PSYMBOL("response");
+    response_symbol.Reset(isolate, String::NewFromUtf8(isolate, "response"));
 
-    target->Set(String::NewSymbol("Call"), t->GetFunction());
+    target->Set(String::NewFromUtf8(isolate, "Call"), t->GetFunction());
 }
 
 // Used by LSHandle to create a "Call" object that wraps a particular
 // LSHandle/LSMessageToken pair.
 Local<Object> LS2Call::NewForCall()
 {
-    Local<Function> function = gCallTemplate->GetFunction();
+    v8::Isolate* isolate = v8::Isolate::GetCurrent();
+    Local<FunctionTemplate> lCallTemplate = Local<FunctionTemplate>::New(isolate, gCallTemplate);
+    Local<Function> function = lCallTemplate->GetFunction();
     Local<Object> callObject = function->NewInstance();
     return callObject;
 }
@@ -98,9 +101,9 @@ void LS2Call::Call(const char* busName, const char* payload, int responseLimit)
     bool result;
     void* userData((void*)this);
     if (responseLimit == 1) {
-        result = LSCallOneReply(fHandle->Get(), busName, payload, &LS2Call::ResponseCallback, userData, &fToken, err);                
+        result = LSCallOneReply(fHandle->Get(), busName, payload, &LS2Call::ResponseCallback, userData, &fToken, err);
     } else {
-        result = LSCall(fHandle->Get(), busName, payload, &LS2Call::ResponseCallback, userData, &fToken, err);        
+        result = LSCall(fHandle->Get(), busName, payload, &LS2Call::ResponseCallback, userData, &fToken, err);
     }
     if (!result) {
         err.ThrowError();
@@ -109,22 +112,24 @@ void LS2Call::Call(const char* busName, const char* payload, int responseLimit)
 }
 
 // Called by V8 when the "Call" function is used with new.
-Handle<Value> LS2Call::New(const Arguments& args)
+void LS2Call::New(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
     try {
 	    LS2Call *m = new LS2Call();
 	    m->Wrap(args.This());
-	    return args.This();
+        args.GetReturnValue().Set(args.This());
     } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
+        args.GetReturnValue().Set(args.GetIsolate()->ThrowException(v8::Exception::Error(
+                v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), ex.what()))));
     } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
+        args.GetReturnValue().Set(args.GetIsolate()->ThrowException(v8::Exception::Error(
+                v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), "Native function threw an unknown exception."))));
     }
 }
 
-Handle<Value> LS2Call::CancelWrapper(const Arguments& args)
+void LS2Call::CancelWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return VoidMemberFunctionWrapper<LS2Call>(&LS2Call::Cancel, args);
+    VoidMemberFunctionWrapper<LS2Call>(&LS2Call::Cancel, args);
 }
 
 void LS2Call::Cancel()
@@ -133,9 +138,9 @@ void LS2Call::Cancel()
     fToken = LSMESSAGE_TOKEN_INVALID;
 }
 
-Handle<Value> LS2Call::SetResponseTimeoutWrapper(const Arguments& args)
+void LS2Call::SetResponseTimeoutWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-	return VoidMemberFunctionWrapper<LS2Call, int>(&LS2Call::SetResponseTimeout, args);
+    VoidMemberFunctionWrapper<LS2Call, int>(&LS2Call::SetResponseTimeout, args);
 }
 
 void LS2Call::SetResponseTimeout(int timeout_ms)
@@ -165,10 +170,11 @@ bool LS2Call::ResponseCallback(LSHandle*, LSMessage *message, void *ctx)
 
 bool LS2Call::ResponseArrived(LSMessage *message)
 {
-    HandleScope scope;
+    v8::Isolate* isolate = Isolate::GetCurrent();
+    HandleScope scope(isolate);
 
     fResponseCount+=1;
-    EmitMessage(response_symbol, message);
+    EmitMessage(Local<String>::New(isolate, response_symbol), message);
     const char* category = LSMessageGetCategory(message);
     bool messageInErrorCategory = (category && strcmp(LUNABUS_ERROR_CATEGORY, category) == 0);    
     if (messageInErrorCategory || (fResponseLimit != kUnlimitedResponses && fResponseCount >= fResponseLimit)) {
diff --git a/src/node_ls2_call.h b/src/node_ls2_call.h
index f3ae361..06d3e18 100644
--- a/src/node_ls2_call.h
+++ b/src/node_ls2_call.h
@@ -25,7 +25,7 @@
 
 class LS2Handle;
 
-class LS2Call : LS2Base {
+class LS2Call : public LS2Base {
 public:
     enum {kUnlimitedResponses = 0};
 
@@ -44,10 +44,10 @@ public:
 protected:
 	// Called by V8 when the "Call" function is used with new. This has to be here, but the
 	// resulting "Call" object is useless as it has no matching LSHandle structure.
-	static v8::Handle<v8::Value> New(const v8::Arguments& args);
+    static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
 
-	static v8::Handle<v8::Value> CancelWrapper(const v8::Arguments& args);
-	static v8::Handle<v8::Value> SetResponseTimeoutWrapper(const v8::Arguments& args);
+    static void CancelWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
+	static void SetResponseTimeoutWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
     void Cancel();
 	void SetResponseTimeout(int timeout_ms);
 
diff --git a/src/node_ls2_handle.cpp b/src/node_ls2_handle.cpp
index c5579d2..f98d747 100644
--- a/src/node_ls2_handle.cpp
+++ b/src/node_ls2_handle.cpp
@@ -61,11 +61,12 @@ template <> struct ConvertFromJS<LS2Message*> {
 // to the target object.
 void LS2Handle::Initialize(Handle<Object> target)
 {
-    HandleScope scope;
+    v8::Isolate* isolate = v8::Isolate::GetCurrent();
+    HandleScope scope(isolate);
 
-    Local<FunctionTemplate> t = FunctionTemplate::New(New);
+    Local<FunctionTemplate> t = FunctionTemplate::New(isolate, New);
     
-    t->SetClassName(String::New("palmbus/Handle"));
+    t->SetClassName(v8::String::NewFromUtf8(isolate, "palmbus/Handle"));
 
     t->InstanceTemplate()->SetInternalFieldCount(1);
 
@@ -78,10 +79,10 @@ void LS2Handle::Initialize(Handle<Object> target)
     NODE_SET_PROTOTYPE_METHOD(t, "pushRole", PushRoleWrapper);
     NODE_SET_PROTOTYPE_METHOD(t, "unregister", UnregisterWrapper);
 
-    cancel_symbol = NODE_PSYMBOL("cancel");
-    request_symbol = NODE_PSYMBOL("request");
+    cancel_symbol.Reset(isolate, String::NewFromUtf8(isolate, "cancel"));
+    request_symbol.Reset(isolate, String::NewFromUtf8(isolate, "request"));
 
-    target->Set(String::NewSymbol("Handle"), t->GetFunction());
+    target->Set(String::NewFromUtf8(isolate, "Handle"), t->GetFunction());
 }
 
 void LS2Handle::CallCreated(LS2Call*)
@@ -101,10 +102,11 @@ LSHandle* LS2Handle::Get()
 }
 
 // Called by V8 when the "Handle" function is used with new.
-Handle<Value> LS2Handle::New(const Arguments& args)
+void LS2Handle::New(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
+    v8::Isolate* isolate = v8::Isolate::GetCurrent();
     try {
-        HandleScope scope;
+        HandleScope scope(isolate);
         string busName;
         const char* busNamePtr = NULL;
         bool publicBus = false;
@@ -124,13 +126,13 @@ Handle<Value> LS2Handle::New(const Arguments& args)
         LS2Handle *handle = new LS2Handle(busNamePtr, publicBus);
         handle->Wrap(args.This());
 
-        return args.This();
+        args.GetReturnValue().Set(args.This());
     } catch( std::exception const & ex ) {
-        v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-		return Local<Value>::New(Undefined());
+        isolate->ThrowException( v8::Exception::Error(v8::String::NewFromUtf8(isolate, ex.what())));
+        args.GetReturnValue().SetUndefined();
     } catch( ... ) {
-        v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-		return Local<Value>::New(Undefined());
+        isolate->ThrowException( v8::Exception::Error(v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception.")));
+        args.GetReturnValue().SetUndefined();
     }
 }
 
@@ -161,9 +163,9 @@ LS2Handle::~LS2Handle()
 	}
 }
 
-Handle<Value> LS2Handle::CallWrapper(const Arguments& args)
+void LS2Handle::CallWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return MemberFunctionWrapper<LS2Handle, Handle<Value>, const char*, const char*>(&LS2Handle::Call, args);
+    MemberFunctionWrapper<LS2Handle, Handle<Value>, const char*, const char*>(&LS2Handle::Call, args);
 }
 
 Handle<Value> LS2Handle::Call(const char* busName, const char* payload)
@@ -171,9 +173,9 @@ Handle<Value> LS2Handle::Call(const char* busName, const char* payload)
     return CallInternal(busName, payload, 1);
 }
 
-Handle<Value> LS2Handle::WatchWrapper(const Arguments& args)
+void LS2Handle::WatchWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return MemberFunctionWrapper<LS2Handle, Handle<Value>, const char*, const char*>(&LS2Handle::Watch, args);
+    MemberFunctionWrapper<LS2Handle, Handle<Value>, const char*, const char*>(&LS2Handle::Watch, args);
 }
 
 Handle<Value> LS2Handle::Watch(const char* busName, const char* payload)
@@ -181,9 +183,9 @@ Handle<Value> LS2Handle::Watch(const char* busName, const char* payload)
     return CallInternal(busName, payload, 2);
 }
 
-Handle<Value> LS2Handle::SubscribeWrapper(const Arguments& args)
+void LS2Handle::SubscribeWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return MemberFunctionWrapper<LS2Handle, Handle<Value>, const char*, const char*>(&LS2Handle::Subscribe, args);
+    MemberFunctionWrapper<LS2Handle, Handle<Value>, const char*, const char*>(&LS2Handle::Subscribe, args);
 }
 
 Handle<Value> LS2Handle::Subscribe(const char* busName, const char* payload)
@@ -191,9 +193,9 @@ Handle<Value> LS2Handle::Subscribe(const char* busName, const char* payload)
     return CallInternal(busName, payload, LS2Call::kUnlimitedResponses);
 }
 
-Handle<Value> LS2Handle::CancelWrapper(const Arguments& args)
+void LS2Handle::CancelWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return MemberFunctionWrapper<LS2Handle, bool, LSMessageToken>(&LS2Handle::Cancel, args);
+    MemberFunctionWrapper<LS2Handle, bool, LSMessageToken>(&LS2Handle::Cancel, args);
 }
 
 bool LS2Handle::Cancel(LSMessageToken t)
@@ -206,9 +208,9 @@ bool LS2Handle::Cancel(LSMessageToken t)
     return true;
 }
 
-Handle<Value> LS2Handle::PushRoleWrapper(const Arguments& args)
+void LS2Handle::PushRoleWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return VoidMemberFunctionWrapper<LS2Handle, const char*>(&LS2Handle::PushRole, args);
+    VoidMemberFunctionWrapper<LS2Handle, const char*>(&LS2Handle::PushRole, args);
 }
 
 void LS2Handle::PushRole(const char* pathToRoleFile)
@@ -220,9 +222,9 @@ void LS2Handle::PushRole(const char* pathToRoleFile)
     }
 }
 
-Handle<Value> LS2Handle::RegisterMethodWrapper(const Arguments& args)
+void LS2Handle::RegisterMethodWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return VoidMemberFunctionWrapper<LS2Handle, const char*, const char*>(&LS2Handle::RegisterMethod, args);
+    VoidMemberFunctionWrapper<LS2Handle, const char*, const char*>(&LS2Handle::RegisterMethod, args);
 }
 
 void LS2Handle::RegisterMethod(const char* category, const char* methodName)
@@ -238,9 +240,9 @@ void LS2Handle::RegisterMethod(const char* category, const char* methodName)
     RegisterCategory(category, m->GetMethods());
 }
 
-Handle<Value> LS2Handle::UnregisterWrapper(const Arguments& args)
+void LS2Handle::UnregisterWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return VoidMemberFunctionWrapper<LS2Handle>(&LS2Handle::Unregister, args);
+    VoidMemberFunctionWrapper<LS2Handle>(&LS2Handle::Unregister, args);
 }
 
 void LS2Handle::Unregister()
@@ -271,9 +273,9 @@ void LS2Handle::Unregister()
     fRegisteredMethods.clear();
 }
 
-Handle<Value> LS2Handle::SubscriptionAddWrapper(const Arguments& args)
+void LS2Handle::SubscriptionAddWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return VoidMemberFunctionWrapper<LS2Handle, const char*, LS2Message*>(&LS2Handle::SubscriptionAdd, args);
+    VoidMemberFunctionWrapper<LS2Handle, const char*, LS2Message*>(&LS2Handle::SubscriptionAdd, args);
 }
 
 void LS2Handle::SubscriptionAdd(const char* key, LS2Message* msg)
@@ -291,7 +293,9 @@ Handle<Value> LS2Handle::CallInternal(const char* busName, const char* payload,
     Local<Object> callObject = LS2Call::NewForCall();
     LS2Call *call = node::ObjectWrap::Unwrap<LS2Call>(callObject);
     if (!call) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
+        v8::Isolate* isolate = v8::Isolate::GetCurrent();
+        return isolate->ThrowException(
+                v8::String::NewFromUtf8(isolate, "Unable to unwrap native object."));
     }
     call->SetHandle(this);
     call->Call(busName, payload, responseLimit);
@@ -333,9 +337,10 @@ bool LS2Handle::CancelCallback(LSHandle *sh, LSMessage *message, void *ctx)
 
 bool LS2Handle::CancelArrived(LSMessage *message)
 {
-    HandleScope scope;
+    v8::Isolate* isolate = v8::Isolate::GetCurrent();
+    HandleScope scope(isolate);
     //UnrefIfPending(LSMessageGetResponseToken(message));
-    EmitMessage(cancel_symbol, message);
+    EmitMessage(Local<String>::New(isolate, cancel_symbol), message);
     return true;
 }
 
@@ -347,8 +352,9 @@ bool LS2Handle::RequestCallback(LSHandle *sh, LSMessage *message, void *ctx)
 
 bool LS2Handle::RequestArrived(LSMessage *message)
 {
-    HandleScope scope;
-    EmitMessage(request_symbol, message);
+    v8::Isolate* isolate = v8::Isolate::GetCurrent();
+    HandleScope scope(isolate);
+    EmitMessage(Local<String>::New(isolate, request_symbol), message);
     return true;
 }
 
diff --git a/src/node_ls2_handle.h b/src/node_ls2_handle.h
index 0d5fada..d09a845 100644
--- a/src/node_ls2_handle.h
+++ b/src/node_ls2_handle.h
@@ -42,7 +42,7 @@ public:
 
 protected:
 	// Called by V8 when the "Handle" function is used with new.
-	static v8::Handle<v8::Value> New(const v8::Arguments& args);
+	static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
 
 private:
 	// This constructor is private as these objects are only created by the 
@@ -50,28 +50,28 @@ private:
 	LS2Handle(const char* name = "", bool publicBus = false);
 	virtual ~LS2Handle();
 
-	static v8::Handle<v8::Value> CallWrapper(const v8::Arguments& args);
+	static void CallWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	v8::Handle<v8::Value> Call(const char* busName, const char* payload);
 
-	static v8::Handle<v8::Value> WatchWrapper(const v8::Arguments& args);
+	static void WatchWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	v8::Handle<v8::Value> Watch(const char* busName, const char* payload);
 
-	static v8::Handle<v8::Value> SubscribeWrapper(const v8::Arguments& args);
+	static void SubscribeWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	v8::Handle<v8::Value> Subscribe(const char* busName, const char* payload);
 
-	static v8::Handle<v8::Value> CancelWrapper(const v8::Arguments& args);
+	static void CancelWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	bool Cancel(LSMessageToken token);
 
-	static v8::Handle<v8::Value> RegisterMethodWrapper(const v8::Arguments& args);
+	static void RegisterMethodWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	void RegisterMethod(const char* category, const char* methodName);
 
-	static v8::Handle<v8::Value> UnregisterWrapper(const v8::Arguments& args);
+	static void UnregisterWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	void Unregister();
 
-	static v8::Handle<v8::Value> PushRoleWrapper(const v8::Arguments& args);
+	static void PushRoleWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	void PushRole(const char* pathToRoleFile);
 
-	static v8::Handle<v8::Value> SubscriptionAddWrapper(const v8::Arguments& args);
+	static void SubscriptionAddWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	void SubscriptionAdd(const char* key, LS2Message* msg);
 
 	// Common implmentation for Call, Watch and Subscribe
diff --git a/src/node_ls2_member_function_wrappers.h b/src/node_ls2_member_function_wrappers.h
index d67dcad..b07cb55 100644
--- a/src/node_ls2_member_function_wrappers.h
+++ b/src/node_ls2_member_function_wrappers.h
@@ -1,6 +1,6 @@
 /* @@@LICENSE
 *
-*      Copyright (c) 2010-2013 LG Electronics, Inc.
+*      Copyright (c) 2010-2015 LG Electronics, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -18,912 +18,1082 @@
 
 // Generated file, do not edit. See generate_templates.rb for details on how to regenerate.
 
+#pragma once
+
 // arity: 0, const:
 
-template <typename T,typename RV> v8::Handle<v8::Value> MemberFunctionWrapper(RV (T::*MemFunc)(), v8::Arguments const & args )
+template <typename T,typename RV> void MemberFunctionWrapper(RV (T::*MemFunc)(), const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 0) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 0 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        return ConvertToJS<RV>((o->*MemFunc)());
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate*  isolate = info.GetIsolate();
+  if (info.Length() != 0) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 0 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+    info.GetReturnValue().Set(ConvertToJS<RV>((o->*MemFunc)()));
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 1, const:
 
-template <typename T,typename RV,typename T1> v8::Handle<v8::Value> MemberFunctionWrapper(RV (T::*MemFunc)(T1), v8::Arguments const & args )
+template <typename T,typename RV,typename T1> void MemberFunctionWrapper(RV (T::*MemFunc)(T1), const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 1) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 1 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        return ConvertToJS<RV>((o->*MemFunc)(p1));
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate*  isolate = info.GetIsolate();
+  if (info.Length() != 1) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 1 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+    info.GetReturnValue().Set(ConvertToJS<RV>((o->*MemFunc)(p1)));
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 2, const:
 
-template <typename T,typename RV,typename T1,typename T2> v8::Handle<v8::Value> MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2), v8::Arguments const & args )
+template <typename T,typename RV,typename T1,typename T2> void MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2), const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 2) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 2 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        return ConvertToJS<RV>((o->*MemFunc)(p1,p2));
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate*  isolate = info.GetIsolate();
+  if (info.Length() != 2) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 2 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+    info.GetReturnValue().Set(ConvertToJS<RV>((o->*MemFunc)(p1,p2)));
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 3, const:
 
-template <typename T,typename RV,typename T1,typename T2,typename T3> v8::Handle<v8::Value> MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2,T3), v8::Arguments const & args )
+template <typename T,typename RV,typename T1,typename T2,typename T3> void MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2,T3), const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 3) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 3 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        ConvertFromJS<T3> p3(args[2]);
-
-        return ConvertToJS<RV>((o->*MemFunc)(p1,p2,p3));
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate*  isolate = info.GetIsolate();
+  if (info.Length() != 3) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 3 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+      ConvertFromJS<T3> p3(info[2]);
+    
+    info.GetReturnValue().Set(ConvertToJS<RV>((o->*MemFunc)(p1,p2,p3)));
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 4, const:
 
-template <typename T,typename RV,typename T1,typename T2,typename T3,typename T4> v8::Handle<v8::Value> MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2,T3,T4), v8::Arguments const & args )
+template <typename T,typename RV,typename T1,typename T2,typename T3,typename T4> void MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2,T3,T4), const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 4) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 4 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        ConvertFromJS<T3> p3(args[2]);
-
-        ConvertFromJS<T4> p4(args[3]);
-
-        return ConvertToJS<RV>((o->*MemFunc)(p1,p2,p3,p4));
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate*  isolate = info.GetIsolate();
+  if (info.Length() != 4) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 4 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+      ConvertFromJS<T3> p3(info[2]);
+    
+      ConvertFromJS<T4> p4(info[3]);
+    
+    info.GetReturnValue().Set(ConvertToJS<RV>((o->*MemFunc)(p1,p2,p3,p4)));
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 5, const:
 
-template <typename T,typename RV,typename T1,typename T2,typename T3,typename T4,typename T5> v8::Handle<v8::Value> MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2,T3,T4,T5), v8::Arguments const & args )
+template <typename T,typename RV,typename T1,typename T2,typename T3,typename T4,typename T5> void MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2,T3,T4,T5), const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 5) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 5 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        ConvertFromJS<T3> p3(args[2]);
-
-        ConvertFromJS<T4> p4(args[3]);
-
-        ConvertFromJS<T5> p5(args[4]);
-
-        return ConvertToJS<RV>((o->*MemFunc)(p1,p2,p3,p4,p5));
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate*  isolate = info.GetIsolate();
+  if (info.Length() != 5) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 5 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+      ConvertFromJS<T3> p3(info[2]);
+    
+      ConvertFromJS<T4> p4(info[3]);
+    
+      ConvertFromJS<T5> p5(info[4]);
+    
+    info.GetReturnValue().Set(ConvertToJS<RV>((o->*MemFunc)(p1,p2,p3,p4,p5)));
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 6, const:
 
-template <typename T,typename RV,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> v8::Handle<v8::Value> MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2,T3,T4,T5,T6), v8::Arguments const & args )
+template <typename T,typename RV,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> void MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2,T3,T4,T5,T6), const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 6) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 6 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        ConvertFromJS<T3> p3(args[2]);
-
-        ConvertFromJS<T4> p4(args[3]);
-
-        ConvertFromJS<T5> p5(args[4]);
-
-        ConvertFromJS<T6> p6(args[5]);
-
-        return ConvertToJS<RV>((o->*MemFunc)(p1,p2,p3,p4,p5,p6));
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate*  isolate = info.GetIsolate();
+  if (info.Length() != 6) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 6 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+      ConvertFromJS<T3> p3(info[2]);
+    
+      ConvertFromJS<T4> p4(info[3]);
+    
+      ConvertFromJS<T5> p5(info[4]);
+    
+      ConvertFromJS<T6> p6(info[5]);
+    
+    info.GetReturnValue().Set(ConvertToJS<RV>((o->*MemFunc)(p1,p2,p3,p4,p5,p6)));
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
-// arity: 0, const:
+// arity: 0, const: 
 
-template <typename T> v8::Handle<v8::Value> VoidMemberFunctionWrapper(void (T::*MemFunc)(), v8::Arguments const & args )
+template <typename T> void VoidMemberFunctionWrapper(void (T::*MemFunc)(), const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 0) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 0 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        (o->*MemFunc)();
-        return v8::Undefined();
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 0) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 0 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+     (o->*MemFunc)();
+     info.GetReturnValue().SetUndefined();
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
-// arity: 1, const:
+// arity: 1, const: 
 
-template <typename T,typename T1> v8::Handle<v8::Value> VoidMemberFunctionWrapper(void (T::*MemFunc)(T1), v8::Arguments const & args )
+template <typename T,typename T1> void VoidMemberFunctionWrapper(void (T::*MemFunc)(T1), const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 1) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 1 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        (o->*MemFunc)(p1);
-        return v8::Undefined();
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 1) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 1 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+     (o->*MemFunc)(p1);
+     info.GetReturnValue().SetUndefined();
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
-// arity: 2, const:
+// arity: 2, const: 
 
-template <typename T,typename T1,typename T2> v8::Handle<v8::Value> VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2), v8::Arguments const & args )
+template <typename T,typename T1,typename T2> void VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2), const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 2) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 2 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        (o->*MemFunc)(p1,p2);
-        return v8::Undefined();
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 2) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 2 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+     (o->*MemFunc)(p1,p2);
+     info.GetReturnValue().SetUndefined();
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
-// arity: 3, const:
+// arity: 3, const: 
 
-template <typename T,typename T1,typename T2,typename T3> v8::Handle<v8::Value> VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2,T3), v8::Arguments const & args )
+template <typename T,typename T1,typename T2,typename T3> void VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2,T3), const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 3) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 3 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        ConvertFromJS<T3> p3(args[2]);
-
-        (o->*MemFunc)(p1,p2,p3);
-        return v8::Undefined();
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 3) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 3 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+      ConvertFromJS<T3> p3(info[2]);
+    
+     (o->*MemFunc)(p1,p2,p3);
+     info.GetReturnValue().SetUndefined();
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
-// arity: 4, const:
+// arity: 4, const: 
 
-template <typename T,typename T1,typename T2,typename T3,typename T4> v8::Handle<v8::Value> VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2,T3,T4), v8::Arguments const & args )
+template <typename T,typename T1,typename T2,typename T3,typename T4> void VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2,T3,T4), const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 4) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 4 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        ConvertFromJS<T3> p3(args[2]);
-
-        ConvertFromJS<T4> p4(args[3]);
-
-        (o->*MemFunc)(p1,p2,p3,p4);
-        return v8::Undefined();
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 4) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 4 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+      ConvertFromJS<T3> p3(info[2]);
+    
+      ConvertFromJS<T4> p4(info[3]);
+    
+     (o->*MemFunc)(p1,p2,p3,p4);
+     info.GetReturnValue().SetUndefined();
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
-// arity: 5, const:
+// arity: 5, const: 
 
-template <typename T,typename T1,typename T2,typename T3,typename T4,typename T5> v8::Handle<v8::Value> VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2,T3,T4,T5), v8::Arguments const & args )
+template <typename T,typename T1,typename T2,typename T3,typename T4,typename T5> void VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2,T3,T4,T5), const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 5) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 5 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        ConvertFromJS<T3> p3(args[2]);
-
-        ConvertFromJS<T4> p4(args[3]);
-
-        ConvertFromJS<T5> p5(args[4]);
-
-        (o->*MemFunc)(p1,p2,p3,p4,p5);
-        return v8::Undefined();
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 5) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 5 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+      ConvertFromJS<T3> p3(info[2]);
+    
+      ConvertFromJS<T4> p4(info[3]);
+    
+      ConvertFromJS<T5> p5(info[4]);
+    
+     (o->*MemFunc)(p1,p2,p3,p4,p5);
+     info.GetReturnValue().SetUndefined();
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
-// arity: 6, const:
+// arity: 6, const: 
 
-template <typename T,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> v8::Handle<v8::Value> VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2,T3,T4,T5,T6), v8::Arguments const & args )
+template <typename T,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> void VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2,T3,T4,T5,T6), const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 6) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 6 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        ConvertFromJS<T3> p3(args[2]);
-
-        ConvertFromJS<T4> p4(args[3]);
-
-        ConvertFromJS<T5> p5(args[4]);
-
-        ConvertFromJS<T6> p6(args[5]);
-
-        (o->*MemFunc)(p1,p2,p3,p4,p5,p6);
-        return v8::Undefined();
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 6) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 6 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+      ConvertFromJS<T3> p3(info[2]);
+    
+      ConvertFromJS<T4> p4(info[3]);
+    
+      ConvertFromJS<T5> p5(info[4]);
+    
+      ConvertFromJS<T6> p6(info[5]);
+    
+     (o->*MemFunc)(p1,p2,p3,p4,p5,p6);
+     info.GetReturnValue().SetUndefined();
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 0, const: const
 
-template <typename T,typename RV> v8::Handle<v8::Value> MemberFunctionWrapper(RV (T::*MemFunc)() const, v8::Arguments const & args )
+template <typename T,typename RV> void MemberFunctionWrapper(RV (T::*MemFunc)() const, const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 0) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 0 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        return ConvertToJS<RV>((o->*MemFunc)());
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate*  isolate = info.GetIsolate();
+  if (info.Length() != 0) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 0 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+    info.GetReturnValue().Set(ConvertToJS<RV>((o->*MemFunc)()));
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 1, const: const
 
-template <typename T,typename RV,typename T1> v8::Handle<v8::Value> MemberFunctionWrapper(RV (T::*MemFunc)(T1) const, v8::Arguments const & args )
+template <typename T,typename RV,typename T1> void MemberFunctionWrapper(RV (T::*MemFunc)(T1) const, const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 1) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 1 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        return ConvertToJS<RV>((o->*MemFunc)(p1));
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate*  isolate = info.GetIsolate();
+  if (info.Length() != 1) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 1 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+    info.GetReturnValue().Set(ConvertToJS<RV>((o->*MemFunc)(p1)));
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 2, const: const
 
-template <typename T,typename RV,typename T1,typename T2> v8::Handle<v8::Value> MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2) const, v8::Arguments const & args )
+template <typename T,typename RV,typename T1,typename T2> void MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2) const, const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 2) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 2 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        return ConvertToJS<RV>((o->*MemFunc)(p1,p2));
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate*  isolate = info.GetIsolate();
+  if (info.Length() != 2) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 2 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+    info.GetReturnValue().Set(ConvertToJS<RV>((o->*MemFunc)(p1,p2)));
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 3, const: const
 
-template <typename T,typename RV,typename T1,typename T2,typename T3> v8::Handle<v8::Value> MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2,T3) const, v8::Arguments const & args )
+template <typename T,typename RV,typename T1,typename T2,typename T3> void MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2,T3) const, const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 3) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 3 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        ConvertFromJS<T3> p3(args[2]);
-
-        return ConvertToJS<RV>((o->*MemFunc)(p1,p2,p3));
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate*  isolate = info.GetIsolate();
+  if (info.Length() != 3) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 3 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+      ConvertFromJS<T3> p3(info[2]);
+    
+    info.GetReturnValue().Set(ConvertToJS<RV>((o->*MemFunc)(p1,p2,p3)));
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 4, const: const
 
-template <typename T,typename RV,typename T1,typename T2,typename T3,typename T4> v8::Handle<v8::Value> MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2,T3,T4) const, v8::Arguments const & args )
+template <typename T,typename RV,typename T1,typename T2,typename T3,typename T4> void MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2,T3,T4) const, const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 4) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 4 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        ConvertFromJS<T3> p3(args[2]);
-
-        ConvertFromJS<T4> p4(args[3]);
-
-        return ConvertToJS<RV>((o->*MemFunc)(p1,p2,p3,p4));
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate*  isolate = info.GetIsolate();
+  if (info.Length() != 4) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 4 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+      ConvertFromJS<T3> p3(info[2]);
+    
+      ConvertFromJS<T4> p4(info[3]);
+    
+    info.GetReturnValue().Set(ConvertToJS<RV>((o->*MemFunc)(p1,p2,p3,p4)));
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 5, const: const
 
-template <typename T,typename RV,typename T1,typename T2,typename T3,typename T4,typename T5> v8::Handle<v8::Value> MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2,T3,T4,T5) const, v8::Arguments const & args )
+template <typename T,typename RV,typename T1,typename T2,typename T3,typename T4,typename T5> void MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2,T3,T4,T5) const, const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 5) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 5 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        ConvertFromJS<T3> p3(args[2]);
-
-        ConvertFromJS<T4> p4(args[3]);
-
-        ConvertFromJS<T5> p5(args[4]);
-
-        return ConvertToJS<RV>((o->*MemFunc)(p1,p2,p3,p4,p5));
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate*  isolate = info.GetIsolate();
+  if (info.Length() != 5) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 5 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+      ConvertFromJS<T3> p3(info[2]);
+    
+      ConvertFromJS<T4> p4(info[3]);
+    
+      ConvertFromJS<T5> p5(info[4]);
+    
+    info.GetReturnValue().Set(ConvertToJS<RV>((o->*MemFunc)(p1,p2,p3,p4,p5)));
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 6, const: const
 
-template <typename T,typename RV,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> v8::Handle<v8::Value> MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2,T3,T4,T5,T6) const, v8::Arguments const & args )
+template <typename T,typename RV,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> void MemberFunctionWrapper(RV (T::*MemFunc)(T1,T2,T3,T4,T5,T6) const, const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 6) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 6 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        ConvertFromJS<T3> p3(args[2]);
-
-        ConvertFromJS<T4> p4(args[3]);
-
-        ConvertFromJS<T5> p5(args[4]);
-
-        ConvertFromJS<T6> p6(args[5]);
-
-        return ConvertToJS<RV>((o->*MemFunc)(p1,p2,p3,p4,p5,p6));
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate*  isolate = info.GetIsolate();
+  if (info.Length() != 6) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 6 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+      ConvertFromJS<T3> p3(info[2]);
+    
+      ConvertFromJS<T4> p4(info[3]);
+    
+      ConvertFromJS<T5> p5(info[4]);
+    
+      ConvertFromJS<T6> p6(info[5]);
+    
+    info.GetReturnValue().Set(ConvertToJS<RV>((o->*MemFunc)(p1,p2,p3,p4,p5,p6)));
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::Exception::Error(v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 0, const:  const
 
-template <typename T> v8::Handle<v8::Value> VoidMemberFunctionWrapper(void (T::*MemFunc)() const, v8::Arguments const & args )
+template <typename T> void VoidMemberFunctionWrapper(void (T::*MemFunc)() const, const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 0) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 0 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        (o->*MemFunc)();
-        return v8::Undefined();
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 0) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 0 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+     (o->*MemFunc)();
+     info.GetReturnValue().SetUndefined();
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 1, const:  const
 
-template <typename T,typename T1> v8::Handle<v8::Value> VoidMemberFunctionWrapper(void (T::*MemFunc)(T1) const, v8::Arguments const & args )
+template <typename T,typename T1> void VoidMemberFunctionWrapper(void (T::*MemFunc)(T1) const, const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 1) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 1 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        (o->*MemFunc)(p1);
-        return v8::Undefined();
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 1) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 1 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+     (o->*MemFunc)(p1);
+     info.GetReturnValue().SetUndefined();
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 2, const:  const
 
-template <typename T,typename T1,typename T2> v8::Handle<v8::Value> VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2) const, v8::Arguments const & args )
+template <typename T,typename T1,typename T2> void VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2) const, const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 2) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 2 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        (o->*MemFunc)(p1,p2);
-        return v8::Undefined();
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 2) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 2 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+     (o->*MemFunc)(p1,p2);
+     info.GetReturnValue().SetUndefined();
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 3, const:  const
 
-template <typename T,typename T1,typename T2,typename T3> v8::Handle<v8::Value> VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2,T3) const, v8::Arguments const & args )
+template <typename T,typename T1,typename T2,typename T3> void VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2,T3) const, const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 3) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 3 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        ConvertFromJS<T3> p3(args[2]);
-
-        (o->*MemFunc)(p1,p2,p3);
-        return v8::Undefined();
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 3) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 3 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+      ConvertFromJS<T3> p3(info[2]);
+    
+     (o->*MemFunc)(p1,p2,p3);
+     info.GetReturnValue().SetUndefined();
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 4, const:  const
 
-template <typename T,typename T1,typename T2,typename T3,typename T4> v8::Handle<v8::Value> VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2,T3,T4) const, v8::Arguments const & args )
+template <typename T,typename T1,typename T2,typename T3,typename T4> void VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2,T3,T4) const, const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 4) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 4 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        ConvertFromJS<T3> p3(args[2]);
-
-        ConvertFromJS<T4> p4(args[3]);
-
-        (o->*MemFunc)(p1,p2,p3,p4);
-        return v8::Undefined();
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 4) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 4 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+      ConvertFromJS<T3> p3(info[2]);
+    
+      ConvertFromJS<T4> p4(info[3]);
+    
+     (o->*MemFunc)(p1,p2,p3,p4);
+     info.GetReturnValue().SetUndefined();
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 5, const:  const
 
-template <typename T,typename T1,typename T2,typename T3,typename T4,typename T5> v8::Handle<v8::Value> VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2,T3,T4,T5) const, v8::Arguments const & args )
+template <typename T,typename T1,typename T2,typename T3,typename T4,typename T5> void VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2,T3,T4,T5) const, const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 5) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 5 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        ConvertFromJS<T3> p3(args[2]);
-
-        ConvertFromJS<T4> p4(args[3]);
-
-        ConvertFromJS<T5> p5(args[4]);
-
-        (o->*MemFunc)(p1,p2,p3,p4,p5);
-        return v8::Undefined();
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 5) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 5 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+      ConvertFromJS<T3> p3(info[2]);
+    
+      ConvertFromJS<T4> p4(info[3]);
+    
+      ConvertFromJS<T5> p5(info[4]);
+    
+     (o->*MemFunc)(p1,p2,p3,p4,p5);
+     info.GetReturnValue().SetUndefined();
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
 
 // arity: 6, const:  const
 
-template <typename T,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> v8::Handle<v8::Value> VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2,T3,T4,T5,T6) const, v8::Arguments const & args )
+template <typename T,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> void VoidMemberFunctionWrapper(void (T::*MemFunc)(T1,T2,T3,T4,T5,T6) const, const v8::FunctionCallbackInfo<v8::Value>& info )
 {
-    if (args.Length() != 6) {
-        return ThrowException(v8::Exception::Error(
-                                  v8::String::New("Invalid number of parameters, 6 expected.")));
-    }
-
-    T *o = node::ObjectWrap::Unwrap<T>(args.This());
-    if (!o) {
-        return v8::ThrowException(v8::String::New("Unable to unwrap native object."));
-    }
-
-    try {
-
-        ConvertFromJS<T1> p1(args[0]);
-
-        ConvertFromJS<T2> p2(args[1]);
-
-        ConvertFromJS<T3> p3(args[2]);
-
-        ConvertFromJS<T4> p4(args[3]);
-
-        ConvertFromJS<T5> p5(args[4]);
-
-        ConvertFromJS<T6> p6(args[5]);
-
-        (o->*MemFunc)(p1,p2,p3,p4,p5,p6);
-        return v8::Undefined();
-    } catch( std::exception const & ex ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
-    } catch( ... ) {
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
-    }
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 6) {
+    info.GetReturnValue().Set(isolate->ThrowException(v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Invalid number of parameters, 6 expected."))));
+    return;
+  }
+
+  T *o = node::ObjectWrap::Unwrap<T>(info.This());
+  if (!o) {
+    info.GetReturnValue().Set(isolate->ThrowException(
+      v8::String::NewFromUtf8(isolate, "Unable to unwrap native object.")));
+    return;
+  }
+
+  try {
+    
+      ConvertFromJS<T1> p1(info[0]);
+    
+      ConvertFromJS<T2> p2(info[1]);
+    
+      ConvertFromJS<T3> p3(info[2]);
+    
+      ConvertFromJS<T4> p4(info[3]);
+    
+      ConvertFromJS<T5> p5(info[4]);
+    
+      ConvertFromJS<T6> p6(info[5]);
+    
+     (o->*MemFunc)(p1,p2,p3,p4,p5,p6);
+     info.GetReturnValue().SetUndefined();
+  } catch( std::exception const & ex ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, ex.what()))));
+  } catch( ... ) {
+    info.GetReturnValue().Set(isolate->ThrowException( v8::Exception::Error(
+      v8::String::NewFromUtf8(isolate, "Native function threw an unknown exception."))));
+  }
 }
 
 
diff --git a/src/node_ls2_message.cpp b/src/node_ls2_message.cpp
index 74aa21f..6e48ed7 100644
--- a/src/node_ls2_message.cpp
+++ b/src/node_ls2_message.cpp
@@ -31,7 +31,7 @@ using namespace node;
 // of how the conversion system works.
 template <> v8::Handle<v8::Value> ConvertToJS<LSMessageToken>(LSMessageToken v)
 {
-    return v8::Integer::NewFromUnsigned(v);
+    return v8::Integer::NewFromUnsigned(v8::Isolate::GetCurrent(), v);
 }
 
 // Need to hold on to a reference to the function template for use by
@@ -42,13 +42,14 @@ Persistent<FunctionTemplate> LS2Message::gMessageTemplate;
 // to the target object.
 void LS2Message::Initialize (Handle<Object> target)
 {
-    HandleScope scope;
+    v8::Isolate* isolate = v8::Isolate::GetCurrent();
+    HandleScope scope(isolate);
 
-    Local<FunctionTemplate> t = FunctionTemplate::New(New);
+    Local<FunctionTemplate> t = FunctionTemplate::New(isolate, New);
 
-    t->SetClassName(String::New("palmbus/Message"));
+    t->SetClassName(v8::String::NewFromUtf8(isolate, "palmbus/Message"));
 
-    gMessageTemplate = Persistent<FunctionTemplate>::New(t);
+    gMessageTemplate.Reset(isolate, t);
 
     t->InstanceTemplate()->SetInternalFieldCount(1);
 
@@ -66,7 +67,7 @@ void LS2Message::Initialize (Handle<Object> target)
     NODE_SET_PROTOTYPE_METHOD(t, "isSubscription", IsSubscriptionWrapper);
     NODE_SET_PROTOTYPE_METHOD(t, "respond", RespondWrapper);
 
-    target->Set(String::NewSymbol("Message"), t->GetFunction());
+    target->Set(String::String::NewFromUtf8(isolate, "Message"), t->GetFunction());
 }
 
 // Used by LSHandle to create a "Message" object that wraps a particular
@@ -75,7 +76,8 @@ Local<Value> LS2Message::NewFromMessage(LSMessage* message)
 {
     TryCatch try_catch;
 
-    Local<Function> function = gMessageTemplate->GetFunction();
+    v8::Isolate* isolate = v8::Isolate::GetCurrent();
+    Local<Function> function = v8::Local<FunctionTemplate>::New(isolate, gMessageTemplate)->GetFunction();
     Local<Object> messageObject = function->NewInstance();
 
     // If we get an exception in LS2Message::New, then it will return
@@ -85,7 +87,8 @@ Local<Value> LS2Message::NewFromMessage(LSMessage* message)
     if (!messageObject.IsEmpty()) {
         LS2Message *m = node::ObjectWrap::Unwrap<LS2Message>(messageObject);
         if (!m) {
-            return Local<Value>::New(v8::ThrowException(v8::String::New("Unable to unwrap native object.")));
+            return isolate->ThrowException(
+                    v8::String::NewFromUtf8(isolate, "Unable to unwrap native object."));
         }
         m->SetMessage(message);
     } else {
@@ -108,21 +111,21 @@ LSMessage* LS2Message::Get() const
 // This function exists because it is a requirement of template functions. 
 // The object created with it will not be very useful, since the LS2Message
 // object doesn't correspond to any lower level LSMessage.
-Handle<Value> LS2Message::New(const Arguments& args)
+void LS2Message::New(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
     try {
         LS2Message *m = new LS2Message();
         m->Wrap(args.This());
-        return args.This();
+        args.GetReturnValue().Set(args .This());
     } catch (std::bad_alloc const & ex) {
         syslog(LOG_USER | LOG_CRIT, "%s: throwing memory allocation exception: %s", __func__, ex.what());
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
+        args.GetReturnValue().Set(args.GetIsolate()->ThrowException( v8::Exception::Error(v8::String::NewFromUtf8(args.GetIsolate(), ex.what()))));
     } catch( std::exception const & ex ) {
         syslog(LOG_USER | LOG_CRIT, "%s: throwing standard exception: %s", __func__, ex.what());
-        return v8::ThrowException( v8::Exception::Error(v8::String::New(ex.what())));
+        args.GetReturnValue().Set(args.GetIsolate()->ThrowException( v8::Exception::Error(v8::String::NewFromUtf8(args.GetIsolate(), ex.what()))));
     } catch( ... ) {
         syslog(LOG_USER | LOG_CRIT, "%s: throwing other exception", __func__);
-        return v8::ThrowException( v8::Exception::Error(v8::String::New("Native function threw an unknown exception.")));
+        args.GetReturnValue().Set(args.GetIsolate()->ThrowException( v8::Exception::Error(v8::String::NewFromUtf8(args.GetIsolate(), "Native function threw an unknown exception."))));
     }
 }
 
@@ -156,9 +159,9 @@ void LS2Message::SetMessage(LSMessage* m)
     }
 }
 
-v8::Handle<v8::Value> LS2Message::ApplicationIDWrapper(const v8::Arguments& args)
+void LS2Message::ApplicationIDWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return MemberFunctionWrapper<LS2Message, const char*>(&LS2Message::ApplicationID, args);
+    MemberFunctionWrapper<LS2Message, const char*>(&LS2Message::ApplicationID, args);
 }
 
 const char* LS2Message::ApplicationID() const
@@ -166,9 +169,9 @@ const char* LS2Message::ApplicationID() const
     return GetString(LSMessageGetApplicationID);
 }
 
-v8::Handle<v8::Value> LS2Message::CategoryWrapper(const v8::Arguments& args)
+void LS2Message::CategoryWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return MemberFunctionWrapper<LS2Message, const char*>(&LS2Message::Category, args);
+    MemberFunctionWrapper<LS2Message, const char*>(&LS2Message::Category, args);
 }
 
 const char* LS2Message::Category() const
@@ -176,9 +179,9 @@ const char* LS2Message::Category() const
     return GetString(LSMessageGetCategory);
 }
 
-v8::Handle<v8::Value> LS2Message::IsSubscriptionWrapper(const v8::Arguments& args)
+void LS2Message::IsSubscriptionWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return MemberFunctionWrapper<LS2Message, bool>(&LS2Message::IsSubscription, args);
+    MemberFunctionWrapper<LS2Message, bool>(&LS2Message::IsSubscription, args);
 }
 
 bool LS2Message::IsSubscription() const
@@ -187,9 +190,9 @@ bool LS2Message::IsSubscription() const
     return LSMessageIsSubscription(fMessage);
 }
 
-v8::Handle<v8::Value> LS2Message::KindWrapper(const v8::Arguments& args)
+void LS2Message::KindWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return MemberFunctionWrapper<LS2Message, const char*>(&LS2Message::Kind, args);
+    MemberFunctionWrapper<LS2Message, const char*>(&LS2Message::Kind, args);
 }
 
 const char* LS2Message::Kind() const
@@ -197,9 +200,9 @@ const char* LS2Message::Kind() const
     return GetString(LSMessageGetKind);
 }
 
-v8::Handle<v8::Value> LS2Message::MethodWrapper(const v8::Arguments& args)
+void LS2Message::MethodWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return MemberFunctionWrapper<LS2Message, const char*>(&LS2Message::Method, args);
+    MemberFunctionWrapper<LS2Message, const char*>(&LS2Message::Method, args);
 }
 
 const char* LS2Message::Method() const
@@ -207,9 +210,9 @@ const char* LS2Message::Method() const
     return GetString(LSMessageGetMethod);
 }
 
-v8::Handle<v8::Value> LS2Message::PayloadWrapper(const v8::Arguments& args)
+void LS2Message::PayloadWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return MemberFunctionWrapper<LS2Message, const char*>(&LS2Message::Payload, args);
+    MemberFunctionWrapper<LS2Message, const char*>(&LS2Message::Payload, args);
 }
 
 const char* LS2Message::Payload() const
@@ -217,9 +220,9 @@ const char* LS2Message::Payload() const
     return GetString(LSMessageGetPayload);
 }
 
-v8::Handle<v8::Value> LS2Message::PrintWrapper(const v8::Arguments& args)
+void LS2Message::PrintWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return VoidMemberFunctionWrapper<LS2Message>(&LS2Message::Print, args);
+    VoidMemberFunctionWrapper<LS2Message>(&LS2Message::Print, args);
 }
 
 void LS2Message::Print() const
@@ -228,9 +231,9 @@ void LS2Message::Print() const
     LSMessagePrint(fMessage, stderr);
 }
 
-v8::Handle<v8::Value> LS2Message::RespondWrapper(const v8::Arguments& args)
+void LS2Message::RespondWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return MemberFunctionWrapper<LS2Message, bool, const char*>(&LS2Message::Respond, args);
+    MemberFunctionWrapper<LS2Message, bool, const char*>(&LS2Message::Respond, args);
 }
 
 bool LS2Message::Respond(const char* payload) const
@@ -244,9 +247,9 @@ bool LS2Message::Respond(const char* payload) const
     return true;
 }
 
-v8::Handle<v8::Value> LS2Message::ResponseTokenWrapper(const v8::Arguments& args)
+void LS2Message::ResponseTokenWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return MemberFunctionWrapper<LS2Message, LSMessageToken>(&LS2Message::ResponseToken, args);
+    MemberFunctionWrapper<LS2Message, LSMessageToken>(&LS2Message::ResponseToken, args);
 }
 
 LSMessageToken LS2Message::ResponseToken() const
@@ -254,9 +257,9 @@ LSMessageToken LS2Message::ResponseToken() const
     return GetToken(LSMessageGetResponseToken);
 }
 
-v8::Handle<v8::Value> LS2Message::SenderWrapper(const v8::Arguments& args)
+void LS2Message::SenderWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return MemberFunctionWrapper<LS2Message, const char*>(&LS2Message::Sender, args);
+    MemberFunctionWrapper<LS2Message, const char*>(&LS2Message::Sender, args);
 }
 
 const char* LS2Message::Sender() const
@@ -264,9 +267,9 @@ const char* LS2Message::Sender() const
     return GetString(LSMessageGetSender);
 }
 
-v8::Handle<v8::Value> LS2Message::SenderServiceNameWrapper(const v8::Arguments& args)
+void LS2Message::SenderServiceNameWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return MemberFunctionWrapper<LS2Message, const char*>(&LS2Message::SenderServiceName, args);
+    MemberFunctionWrapper<LS2Message, const char*>(&LS2Message::SenderServiceName, args);
 }
 
 const char* LS2Message::SenderServiceName() const
@@ -274,9 +277,9 @@ const char* LS2Message::SenderServiceName() const
     return GetString(LSMessageGetSenderServiceName);
 }
 
-v8::Handle<v8::Value> LS2Message::TokenWrapper(const v8::Arguments& args)
+void LS2Message::TokenWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return MemberFunctionWrapper<LS2Message, LSMessageToken>(&LS2Message::Token, args);
+    MemberFunctionWrapper<LS2Message, LSMessageToken>(&LS2Message::Token, args);
 }
 
 LSMessageToken LS2Message::Token() const
@@ -284,9 +287,9 @@ LSMessageToken LS2Message::Token() const
     return GetToken(LSMessageGetToken);
 }
 
-v8::Handle<v8::Value> LS2Message::UniqueTokenWrapper(const v8::Arguments& args)
+void LS2Message::UniqueTokenWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    return MemberFunctionWrapper<LS2Message, const char*>(&LS2Message::UniqueToken, args);
+    MemberFunctionWrapper<LS2Message, const char*>(&LS2Message::UniqueToken, args);
 }
 
 const char* LS2Message::UniqueToken() const
diff --git a/src/node_ls2_message.h b/src/node_ls2_message.h
index 2b7ca5b..dcfe234 100644
--- a/src/node_ls2_message.h
+++ b/src/node_ls2_message.h
@@ -42,7 +42,7 @@ protected:
 	// Called by V8 when the "Message" function is used with new. This has to be here, but the
 	// resulting "Message" object is useless as it has no matching LSMessage structure from
 	// the lunaservice library.
-	static v8::Handle<v8::Value> New(const v8::Arguments& args);
+	static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
 
 private:
 	// This constructor is private as these objects are only created by the 
@@ -55,43 +55,43 @@ private:
     void SetMessage(LSMessage* m);
 
 	// Wrappers and accessors for use in the "Message" function template. 
-	static v8::Handle<v8::Value> ApplicationIDWrapper(const v8::Arguments& args);
+	static void ApplicationIDWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	const char* ApplicationID() const;
 
-	static v8::Handle<v8::Value> CategoryWrapper(const v8::Arguments& args);
+	static void CategoryWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	const char* Category() const;
 
-	static v8::Handle<v8::Value> IsSubscriptionWrapper(const v8::Arguments& args);
+	static void IsSubscriptionWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	bool IsSubscription() const;
 
-	static v8::Handle<v8::Value> KindWrapper(const v8::Arguments& args);
+	static void KindWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	const char* Kind() const;
 
-	static v8::Handle<v8::Value> MethodWrapper(const v8::Arguments& args);
+	static void MethodWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	const char* Method() const;
 
-	static v8::Handle<v8::Value> PayloadWrapper(const v8::Arguments& args);
+	static void PayloadWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	const char* Payload() const;
 
-	static v8::Handle<v8::Value> PrintWrapper(const v8::Arguments& args);
+	static void PrintWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	void Print() const;
 
-	static v8::Handle<v8::Value> RespondWrapper(const v8::Arguments& args);
+	static void RespondWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	bool Respond(const char* payload) const;
 
-	static v8::Handle<v8::Value> ResponseTokenWrapper(const v8::Arguments& args);
+	static void ResponseTokenWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	LSMessageToken ResponseToken() const;
 
-	static v8::Handle<v8::Value> SenderWrapper(const v8::Arguments& args);
+	static void SenderWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	const char* Sender() const;
 
-	static v8::Handle<v8::Value> SenderServiceNameWrapper(const v8::Arguments& args);
+	static void SenderServiceNameWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	const char* SenderServiceName() const;
 
-	static v8::Handle<v8::Value> TokenWrapper(const v8::Arguments& args);
+	static void TokenWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	LSMessageToken Token() const;
 
-	static v8::Handle<v8::Value> UniqueTokenWrapper(const v8::Arguments& args);
+	static void UniqueTokenWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	const char* UniqueToken() const;
 
 	// Wrapper around an LSMessage string getter function that will throw an
diff --git a/src/node_ls2_utils.cpp b/src/node_ls2_utils.cpp
index 63f37cb..62c1610 100644
--- a/src/node_ls2_utils.cpp
+++ b/src/node_ls2_utils.cpp
@@ -20,17 +20,17 @@
 
 template <> v8::Handle<v8::Value> ConvertToJS<const char*>(const char* v)
 {
-    return v8::String::New(v);
+    return v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), v);
 }
 
 template <> v8::Handle<v8::Value> ConvertToJS<uint32_t>(uint32_t v)
 {
-    return v8::Integer::NewFromUnsigned(v);
+    return v8::Integer::NewFromUnsigned(v8::Isolate::GetCurrent(), v);
 }
 
 template <> v8::Handle<v8::Value> ConvertToJS<bool>(bool v)
 {
-    return v8::Boolean::New(v);
+    return v8::Boolean::New(v8::Isolate::GetCurrent(), v);
 }
 
 template <> v8::Handle<v8::Value> ConvertToJS< v8::Handle<v8::Value> >(v8::Handle<v8::Value>  v)
-- 
2.1.4

